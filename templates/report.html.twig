{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report</h1>
    <a style="margin-bottom: 0.7rem" href="#kmom01">kmom01</a>
    <a style="margin-bottom: 0.7rem" href="#kmom02">kmom02</a>
    <a style="margin-bottom: 0.7rem" href="#kmom03">kmom03</a>
    <a style="margin-bottom: 0.7rem" href="#kmom04">kmom04</a>
    <a style="margin-bottom: 0.7rem" href="#kmom05">kmom05</a>
    <a style="margin-bottom: 0.7rem"href="#kmom06">kmom06</a>
    <a style="margin-bottom: 0.7rem" href="#kmom10">kmom10</a>
    <h2 style="margin-top:1.4rem;" id="kmom01">Kmom01</h2>
    {# <p>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.
Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver 
veta/förstå för att kunna komma igång och skapa sina första klasser?
Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?

Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? 
Är det några särskilda områden som du känner att du vill veta mer om? Lyft fram några delar av artikeln som du känner mer värdefulla. #}

<p>Den enda direkta tidigare erfarenheten jag har med objektorientering är från OOPython-kursen. Spontant känns det ju som principen med 
OOp är densamma i många olika språk. Simpelt och generellt beskrivet är det ett sätt att skapa objekt som håller sina egna 
attribut och funktioner. Vilket låter som en logisk modell då människan har ett objektorienterad tankesätt, alla saker har sitt 
användningsområde. Generellt tycker jag PHPs sätt att skapa klasser och objekt påminner mycket om hur man gör i Python. Exempelvis hur man jobbar med 
eventuell konstruktor, setters och getters. Det som tydligt skiljer är att inget är privat i Python där använder man endast en namnkonvention för att visa att något 
ska hanteras som en tex privat attribut (_attribute). Försöker vi hantera ett privat attribut i PHP som ett publikt (utan setters/getters) så kommer vi få krashad kod eller massa fel. <br> <br>

Frågan "Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver 
veta/förstå för att kunna komma igång och skapa sina första klasser?" är inte helt självklar gällande vilket svar man min ha. Men 
ska man svara basic så bör man ha en uppfattaning om hur man ska tänka när man deklarerar sina attribut (ska dem vara public, prot, eller private?). 
Rimligt är också om man förstår vad en konstruktor gör samt att när ett object väl är skapat så är objektet en egen instans med ett eget 
state skapat utifrån en klass, man kan säga att klassen är en form av blueprint för ett eventuellt objekt. Ett annat sätt att se på det är att klasser 
är en möjligthet a samla kod som är relevanta för varandra och på så sätt få en bättre struktur och läsbarhet. <br><br>

Strukturen som används i denna uppgiften känns greppbar. Symfony upplevs inledningsvis som stort och tungjobbat när man kommer direkt från att ha använt Express(js). 
Men jag får uppfattningen att Symfony är lite mindre 'magiskt' än tex Express och ger användaren mer manuella möjligheter att hantera problem. Det känns såklart lite 
överväldigande i början men det leder i slutändan till en (förhoppningsvis) djupare förståelse för det man jobbar med. Phps dokumentation är dock ungefär lika 
smidig som Pythons vilket är lite synd, men så är det ibland. <br>


Artikeln 'PHP The right way' föll inte riktigt mig i smaken, det kändes väldigt svårt att avgöra vad som är är viktigt just nu och upplägget bär på samma misstag 
som dem flesta introduktionsartiklar, dem lägger tex 10 meningar på att förklara att en ny sak har kommit sedan version X och den är jättebra o.s.v.  sen efter massa 
(för tillfället) onödiga förklaringar skriver dem en mening om hur man ska använda funktionen/tekniken. Jag misstänker att artikeln blir mer användbar 
ju djupare man behöver dyka i PHP, men vid första anblick känns den lite oinspirerande. Nu lät jag lite negativ, den hade också såklart lite intressanta saker att bjuda på så som 
<a class="a-reset" href="https://phptherightway.com/#openclosed-principle">Open/closed principle</a> vilket är något jag, har blivit, men vill bli mycket bättre på. 
<br><br>
Än sålänge har min sida en grundläggande responsivitet men saknar en del anpassning i navbaren och andra småställen. Jag är osäker på hur mobilanpassad sidan behöver vara så jag 
har bara gjort lite basic anpassning.</p>

    <h2 id="kmom02">Kmom02</h2>
    {# Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.
    Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?
    
    Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod.
    Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?

    Vilken är din TIL för detta kmom? #}
    <p>Arv är ett sätt att strukturera sin kod mer eller mindre. Det innebär att man enklare kan strukturera sin kod i relevanta 'hierarkier'. Som 
    exempel kan vi ta klassikern att (nästan) alla bilar har har attributen en motor och fyra hjul samt metoden gasa(), men färgen kan variera från bil till bil. Då kan vi göra en 
    Bil-klass som har dem relevanta attributen och metoderna för en bils grundliga funktioner. Sedan kan en annan subklass ärva från Bil och på så sätt få
    med sig basmetoderna från Bil. Då kan subklassen fokusera på att specialisera bilen åt något annat håll, typ ändra färg. </p>
    <p>Komposition är en typ av livlineförhållande. Om klassen X som håller/använder sig av Y slutar existera så kommer även klassen Y att försvinna. Man kan  
    jämföra det med att om ett företag går i konkurs/upphör så kommer dem anställdas 'Anställning' försvinna då det i detta fall krävs ett Företag för att erbjuda ett anställningskontrakt.</p>
    <p>När man läser om Interface påminner beskrivningen om hur abstrakta klassmetoder fungerade i Python. Det är ett sätt att tvinga t.e.x en subklass att uppfylla dem 
    krav och funktionerna en klass förväntas ha, beroende på vad det är för klass. Är det ett kortspels-interface så förväntas åtminstonde en deal och shuffle-metod. På så 
    sätt kan kod blir med återanvändbar då jag rent teoretiskt skulle kunna stoppa in vilken kortlek som helst i en kortklass som lyder under ett kortspels-Interface.</p>
    <p>Ett Trait är en samling återanvändbar kod som kan användas i olika klasser. Det är ett alternativ till Arv, i Php kan man inte ärva från flera Föräldraklasser. Då 
    kan trait vara ett alternativ för att lyckas dela kod mellan olika klasser istället. När en klass använder ett trait så kan klassen använda traitens metoder. En tydlig skillnad 
    mellan Trait och Klass, enligt <a class="a-reset" href="https://www.php.net/manual/en/language.oop5.traits.php">Php manualen om Traits</a>, är att ett Trait inte kan instansierias fristående, så som 
    en klass kan.</p>
    <p>Jag är ganska nöjd med min implementation och tycker jag har fått mycket gjort med ganska lite kod. Jag valde dock att inte använda mig av Cards-klassen utan jag gjorde 
    bara en CardGraphics-klass. Anledningen till det är att jag valde att utgå ifrån att en ny kortlek är sorterad och i rätt antal från början. Jag använde mig av ChatGPT för att 
    snabbt göra två arrayer (en value och en key,value) som skulle motsvara kortleken och dess grafik och på så sätt tog det mig ingen tid att påbörja det upplägget. Om jag skulle 
    skrivit båda arrayerna manuellt hade jag nog valt ett annat sätt att skapa kortleken, med tex loopar. Men en vanlig kortlek har alltid 52 kort så jag behövde inte ta hänsyn till 
    några eventuella förändringar på den fronten och det är alltid kul att nyttja sig av ny teknik (Obs, jag har INTE använt ChatGPT för att skriva någon kod utan endast för att underlätta 
    formateringen/framställningen av kort-arrayerna.). <br>
    En sak som skulle kunnat vara bättre är att jag ibland har/hade lite dubblettmetoder som gör samma sak med kortleken i handen beroende på vart du använder metoden(i CardHand eller 
    i DeckOfCards) och det kunde vara vilseledande ibland. Jag har dock rensat bort (nästan) alla onödiga dubblettmetoder och försökt hålla alla metoder som hämtar eller sätter information 
    om DeckOfCards i DeckOfCards samt alla manipulerande metoder i CardHand för att få en lite mer logisk struktur</p>
    <p>Jag missade helt detaljen om att man skulle göra ett UML-diagram och såg detta när jag dubbelkollade kraven innan inlämning. Vilket är lite synd för min del då jag i tidigare kurser 
    märkt att jag skriver lite mer strukturerad kod när jag har en mall att utgå ifrån. Mitt TIL för detta kmom är det jag lärt mig om Trait och Interface. Jag har dock inte nyttjat 
    någon av dem mekanismerna i min kod men jag vill prova på dem längre fram.</p>
    <h2 id="kmom03">Kmom03</h2>
    {# Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i 
    din problemlösning och tankearbete för att strukturera koden kring en applikation?
    Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, 
    vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?
    Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?
    Vilken är din TIL för detta kmom? #}
    <p>
    Jag gjorde först ett flödesdiagram med flödeslogiken jag ville ha i spelet. Jag har inte tittat så mycket på flödesdiagramet då jag gjorde en ganska stark mental 
    notering på hur jag ville jobba under tiden jag gjorde diagramet. Så det var klart ett hjälpmedel, men främst i början för att få igång en vettig och målinriktad start. Jag 
    skrev lite pseudokod innan jag började skriva men jag valde ganska snabbt att skriva den i ett listformat istället då jag var osäker på vad jag behövde för funktioner och struktur, 
    sedan fyllde jag på den lite efter hand. 
    Då kändes det mer hjälpsamt att ha en lista att gå efter som nämner dem flesta grundstenar. En lärdom jag fått av att försöka skriva pseudokod är att jag upplever det som svårt 
    att börja visualisera mig vad jag kommer/inte kommer att behöva i ett sådant tidigt stadie. Det mesta brukar komma när jag fått ihop en grundstruktur, i detta fall avser jag 
    grundstruktur som exempelvis routes och en startsida/slutsida. <br> <br>
    Innan jag började göra någon riktig kodning så gjorde jag alla routes jag kunde tänka mig, framförallt en 'lekroute' som jag använde mycket i början för att prova grundläggande funktioner. 
    Jag implementerade alla klasserna och såg till att jag kunde göra grundläggande saker (dra kort osv, det som gjordes i kmom02). Koden jag skrev i kmom02 har varit smidig att 
    jobba med och jag tycker att jag gjorde ett bra jobb i kmom02 med att förbereda klasserna för kortspelet. <br><br>
    Den grundläggande strukturen i kortspelet är att Game-klassen hanterar spelets flöde, såsom att hålla kolla på vems tur det är, hålla antal spelare, låta spelaren dra ett kort eller 
    inte och utse en vinnare mm. CardHand och CardBank(CB ärver från CH) representerar en spelare och en bank och deras jobb är att kunna manipulera kortleken, hålla sina poäng 
    samt meddela Game om dem blivit tjocka eller inte. Game, CardHand och CardBank har en kompositionsrelation där banken alltid är sista spelaren. Game får(inject) spelartyp, banktyp och en int 
    som talar om hur många spelare som ska vara med och därefter skapar dem (jag har förberett lite grann för att kunna lägga till fler spelare men just nu stödjer spelet bara 1
    bank och 1 spelare). CardGraphics används i kombination med en 'prettyprint-twig-fil' för att kunna skriva ut lite finare kort. Klassen används även som en referens vid sortering 
    av DeckOfCards då den grafiska representationen är sorterad. <br>
    En tydlig förbättringsåtgärd jag kunnat göra är att flytta ansvaret från Game till CardBank när det gäller att kolla om CardBank är färdig med sin tur. Just nu ligger ansvaret 
    för en stor del av CardBanks tur i gameplayCycle() i Game. Det är lite missvisande då det hade varit bättre om CardBank själv skött den biten och returnat data till Game när 
    dess gameplay-cykel är klar. Det är förvisso ingen svår fix men just nu prioriterar jag att lämna in uppgiften. <br>
    Mina åsikter om Symfony är blandade. Jag tycker det är ett otroligt tungjobbat ramverk som man lätt går vilse i. Men samtidigt verkar man ha kontroll över väldigt mycket 
    smådetaljer. Den största nackdelen är nog dokumentationen, den lämnar mycket att önska och har sällan ett relevant svar på det man söker. Så enkelt sammanfattat, Symfony är 
    inte min 'cup of tea' men samtidigt gillar jag att gå utanför min comfort-zone så jag uppskattar upplevelsen. <br> <br>
    Min TIL är att jag tycker det är svårt att planera innan jag börjar, det är något jag behöver träna på.

    </p>
    <h2 id="kmom04">Kmom04</h2>
    {# Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.

    Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?

    Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?

    Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.

    Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.

    Vilken är din TIL för detta kmom? #}
    <p>Jag är ofta skeptisk mot att göra saker med Php i ren allmänhet, men jag får lov att säga att testerna var trivsamma att arbeta med och erbjöd ett bra flow. Jag har upptäckt att det 
    är ganska svårt att testa sin egen kod på ett kritiskt och konstruktivt sätt. Även att majoriteten av min kod var någorlunda lättestad så tyckte jag det var svårt att komma på sätt att testa sönder 
    min kod. Såklart går allt att ta sönder. Men jag upplever det som en hårfin gräns mellan att testa de delar som är vitala för att en klass ska fungera som tänkt och att skriva 
    extremt riktade tester bara för att klassen ska göra fel. Det jag menar är enkelt utryckt att Det finns alltid små hål att täppa och det är ibland svårt att veta vilka som är värda att 
    lägga energi på.</p><br>

    <p>Jag lyckades ganska bra med kodtäckningen, 100% på Card och 93.75% på Game. Som jag tidigare nämnde tycker dock det är utmanade att skriva opartiska och konstruktiva testfall 
    till min egen kod, det kanske kan vara en Nackdel med såkallad 'White-box-testing'? I allmänhet tycker jag dock min kod i Card var ganska lättestad då jag hade många små funktioner som gjorde 
    få saker. Däremot upptäckte jag att Game-klassen har för många ansvarsområden i gameplayCycle(), getWinner() och getMaxScores() vilket gjorde det svårt att att testa olika delar i funktionerna. 
    Det som har kunnat förbättras där är dels att bryta ut kod till flera mindre funktioner men även att flytta över en del av ansvaret i funktionerna till CardHand/Cardbank-klasserna istället. 
    Jag gjorde dock inga större ändringar i min kod då jag ligger lite efter i kursen och försöker lägga min tid på det som är hårda krav. Men jag har en idé om vad som hade behövts om jag hade hunnit.
    </p><br>
    <p>Är testbar kod snygg och ren? Mja, generellt anser jag nog det. Om man klarar av att balansera den OCD man riskerar att uppleva om ALLT ska vara 100% testbart. Att skriva tester till 
    min kod har helt klart gett mig ett nytt perspektiv på vilka brister och fördelar min skrivna kod har. Flera gånger under testningen hittade jag småsaker som hade kunnat vara mycket bättre 
    om jag gjort på något alternativt sätt och lärdomen jag tar med mig till framtida kodingssessioner när jag sitter och skriver lite tveksamma, bökigare och större funktioner är att ställa mig 
    frågan "Kommer det gå att testa det här på ett någorlunda vettigt sätt?". Jag tror det kommer hjälpa mig att skriva lite bättre kod.</p><br>

    <p>Min TIL är att det faktiskt var lite kul att sitta med tester. Vilket jag inte trodde jag skulle tycka. Jag hade gärna i framtiden sett något moment när man ska testa andras kod för att 
    få ett bredare perspektiv. Jag tar gärna emot en extra mening med kritik på just mina tester och deras tillvägagångssätt då jag tror att om jag får en bättre förståelse för hur man 
    ska tänka när man testar kan vara ett sätt för mig att bli en bättre kodare. Detta kursmoment glömde jag helt bort att göra commits så det kommer se snålt ut på githuben detta kmom. 
</p>
    <h2 id="kmom05">Kmom05</h2>
    <p>Kmom1</p>
    <h2 id="kmom06">Kmom06</h2>
    <p>Kmom1</p>
    <h2 id="kmom10">Kmom10</h2>
    <p>Kmom1</p>

{% endblock %}