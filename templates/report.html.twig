{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report</h1>
    <a style="margin-bottom: 0.7rem" href="#kmom01">kmom01</a>
    <a style="margin-bottom: 0.7rem" href="#kmom02">kmom02</a>
    <a style="margin-bottom: 0.7rem" href="#kmom03">kmom03</a>
    <a style="margin-bottom: 0.7rem" href="#kmom04">kmom04</a>
    <a style="margin-bottom: 0.7rem" href="#kmom05">kmom05</a>
    <a style="margin-bottom: 0.7rem"href="#kmom06">kmom06</a>
    <a style="margin-bottom: 0.7rem" href="#kmom10">kmom10</a>
    <h2 style="margin-top:1.4rem;" id="kmom01">Kmom01</h2>
    {# <p>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.
Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver 
veta/förstå för att kunna komma igång och skapa sina första klasser?
Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?

Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? 
Är det några särskilda områden som du känner att du vill veta mer om? Lyft fram några delar av artikeln som du känner mer värdefulla. #}

<p>Den enda direkta tidigare erfarenheten jag har med objektorientering är från OOPython-kursen. Spontant känns det ju som principen med 
OOp är densamma i många olika språk. Simpelt och generellt beskrivet är det ett sätt att skapa objekt som håller sina egna 
attribut och funktioner. Vilket låter som en logisk modell då människan har ett objektorienterad tankesätt, alla saker har sitt 
användningsområde. Generellt tycker jag PHPs sätt att skapa klasser och objekt påminner mycket om hur man gör i Python. Exempelvis hur man jobbar med 
eventuell konstruktor, setters och getters. Det som tydligt skiljer är att inget är privat i Python där använder man endast en namnkonvention för att visa att något 
ska hanteras som en tex privat attribut (_attribute). Försöker vi hantera ett privat attribut i PHP som ett publikt (utan setters/getters) så kommer vi få krashad kod eller massa fel. <br> <br>

Frågan "Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver 
veta/förstå för att kunna komma igång och skapa sina första klasser?" är inte helt självklar gällande vilket svar man min ha. Men 
ska man svara basic så bör man ha en uppfattaning om hur man ska tänka när man deklarerar sina attribut (ska dem vara public, prot, eller private?). 
Rimligt är också om man förstår vad en konstruktor gör samt att när ett object väl är skapat så är objektet en egen instans med ett eget 
state skapat utifrån en klass, man kan säga att klassen är en form av blueprint för ett eventuellt objekt. Ett annat sätt att se på det är att klasser 
är en möjligthet a samla kod som är relevanta för varandra och på så sätt få en bättre struktur och läsbarhet. <br><br>

Strukturen som används i denna uppgiften känns greppbar. Symfony upplevs inledningsvis som stort och tungjobbat när man kommer direkt från att ha använt Express(js). 
Men jag får uppfattningen att Symfony är lite mindre 'magiskt' än tex Express och ger användaren mer manuella möjligheter att hantera problem. Det känns såklart lite 
överväldigande i början men det leder i slutändan till en (förhoppningsvis) djupare förståelse för det man jobbar med. Phps dokumentation är dock ungefär lika 
smidig som Pythons vilket är lite synd, men så är det ibland. <br>


Artikeln 'PHP The right way' föll inte riktigt mig i smaken, det kändes väldigt svårt att avgöra vad som är är viktigt just nu och upplägget bär på samma misstag 
som dem flesta introduktionsartiklar, dem lägger tex 10 meningar på att förklara att en ny sak har kommit sedan version X och den är jättebra o.s.v.  sen efter massa 
(för tillfället) onödiga förklaringar skriver dem en mening om hur man ska använda funktionen/tekniken. Jag misstänker att artikeln blir mer användbar 
ju djupare man behöver dyka i PHP, men vid första anblick känns den lite oinspirerande. Nu lät jag lite negativ, den hade också såklart lite intressanta saker att bjuda på så som 
<a class="a-reset" href="https://phptherightway.com/#openclosed-principle">Open/closed principle</a> vilket är något jag, har blivit, men vill bli mycket bättre på. 
<br><br>
Än sålänge har min sida en grundläggande responsivitet men saknar en del anpassning i navbaren och andra småställen. Jag är osäker på hur mobilanpassad sidan behöver vara så jag 
har bara gjort lite basic anpassning.</p>

    <h2 id="kmom02">Kmom02</h2>
    {# Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.
    Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?
    
    Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod.
    Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?

    Vilken är din TIL för detta kmom? #}
    <p>Arv är ett sätt att strukturera sin kod mer eller mindre. Det innebär att man enklare kan strukturera sin kod i relevanta 'hierarkier'. Som 
    exempel kan vi ta klassikern att (nästan) alla bilar har har attributen en motor och fyra hjul samt metoden gasa(), men färgen kan variera från bil till bil. Då kan vi göra en 
    Bil-klass som har dem relevanta attributen och metoderna för en bils grundliga funktioner. Sedan kan en annan subklass ärva från Bil och på så sätt få
    med sig basmetoderna från Bil. Då kan subklassen fokusera på att specialisera bilen åt något annat håll, typ ändra färg. </p>
    <p>Komposition är en typ av livlineförhållande. Om klassen X som håller/använder sig av Y slutar existera så kommer även klassen Y att försvinna. Man kan  
    jämföra det med att om ett företag går i konkurs/upphör så kommer dem anställdas 'Anställning' försvinna då det i detta fall krävs ett Företag för att erbjuda ett anställningskontrakt.</p>
    <p>När man läser om Interface påminner beskrivningen om hur abstrakta klassmetoder fungerade i Python. Det är ett sätt att tvinga t.e.x en subklass att uppfylla dem 
    krav och funktionerna en klass förväntas ha, beroende på vad det är för klass. Är det ett kortspels-interface så förväntas åtminstonde en deal och shuffle-metod. På så 
    sätt kan kod blir med återanvändbar då jag rent teoretiskt skulle kunna stoppa in vilken kortlek som helst i en kortklass som lyder under ett kortspels-Interface.</p>
    <p>Ett Trait är en samling återanvändbar kod som kan användas i olika klasser. Det är ett alternativ till Arv, i Php kan man inte ärva från flera Föräldraklasser. Då 
    kan trait vara ett alternativ för att lyckas dela kod mellan olika klasser istället. När en klass använder ett trait så kan klassen använda traitens metoder. En tydlig skillnad 
    mellan Trait och Klass, enligt <a class="a-reset" href="https://www.php.net/manual/en/language.oop5.traits.php">Php manualen om Traits</a>, är att ett Trait inte kan instansierias fristående, så som 
    en klass kan.</p>
    <p>Jag är ganska nöjd med min implementation och tycker jag har fått mycket gjort med ganska lite kod. Jag valde dock att inte använda mig av Cards-klassen utan jag gjorde 
    bara en CardGraphics-klass. Anledningen till det är att jag valde att utgå ifrån att en ny kortlek är sorterad och i rätt antal från början. Jag använde mig av ChatGPT för att 
    snabbt göra två arrayer (en value och en key,value) som skulle motsvara kortleken och dess grafik och på så sätt tog det mig ingen tid att påbörja det upplägget. Om jag skulle 
    skrivit båda arrayerna manuellt hade jag nog valt ett annat sätt att skapa kortleken, med tex loopar. Men en vanlig kortlek har alltid 52 kort så jag behövde inte ta hänsyn till 
    några eventuella förändringar på den fronten och det är alltid kul att nyttja sig av ny teknik (Obs, jag har INTE använt ChatGPT för att skriva någon kod utan endast för att underlätta 
    formateringen/framställningen av kort-arrayerna.). <br>
    En sak som skulle kunnat vara bättre är att jag ibland har/hade lite dubblettmetoder som gör samma sak med kortleken i handen beroende på vart du använder metoden(i CardHand eller 
    i DeckOfCards) och det kunde vara vilseledande ibland. Jag har dock rensat bort (nästan) alla onödiga dubblettmetoder och försökt hålla alla metoder som hämtar eller sätter information 
    om DeckOfCards i DeckOfCards samt alla manipulerande metoder i CardHand för att få en lite mer logisk struktur</p>
    <p>Jag missade helt detaljen om att man skulle göra ett UML-diagram och såg detta när jag dubbelkollade kraven innan inlämning. Vilket är lite synd för min del då jag i tidigare kurser 
    märkt att jag skriver lite mer strukturerad kod när jag har en mall att utgå ifrån. Mitt TIL för detta kmom är det jag lärt mig om Trait och Interface. Jag har dock inte nyttjat 
    någon av dem mekanismerna i min kod men jag vill prova på dem längre fram.</p>
    <h2 id="kmom03">Kmom03</h2>
    {# Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i 
    din problemlösning och tankearbete för att strukturera koden kring en applikation?
    Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, 
    vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?
    Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?
    Vilken är din TIL för detta kmom? #}
    <p>
    Jag gjorde först ett flödesdiagram med flödeslogiken jag ville ha i spelet. Jag har inte tittat så mycket på flödesdiagramet då jag gjorde en ganska stark mental 
    notering på hur jag ville jobba under tiden jag gjorde diagramet. Så det var klart ett hjälpmedel, men främst i början för att få igång en vettig och målinriktad start. Jag 
    skrev lite pseudokod innan jag började skriva men jag valde ganska snabbt att skriva den i ett listformat istället då jag var osäker på vad jag behövde för funktioner och struktur, 
    sedan fyllde jag på den lite efter hand. 
    Då kändes det mer hjälpsamt att ha en lista att gå efter som nämner dem flesta grundstenar. En lärdom jag fått av att försöka skriva pseudokod är att jag upplever det som svårt 
    att börja visualisera mig vad jag kommer/inte kommer att behöva i ett sådant tidigt stadie. Det mesta brukar komma när jag fått ihop en grundstruktur, i detta fall avser jag 
    grundstruktur som exempelvis routes och en startsida/slutsida. <br> <br>
    Innan jag började göra någon riktig kodning så gjorde jag alla routes jag kunde tänka mig, framförallt en 'lekroute' som jag använde mycket i början för att prova grundläggande funktioner. 
    Jag implementerade alla klasserna och såg till att jag kunde göra grundläggande saker (dra kort osv, det som gjordes i kmom02). Koden jag skrev i kmom02 har varit smidig att 
    jobba med och jag tycker att jag gjorde ett bra jobb i kmom02 med att förbereda klasserna för kortspelet. <br><br>
    Den grundläggande strukturen i kortspelet är att Game-klassen hanterar spelets flöde, såsom att hålla kolla på vems tur det är, hålla antal spelare, låta spelaren dra ett kort eller 
    inte och utse en vinnare mm. CardHand och CardBank(CB ärver från CH) representerar en spelare och en bank och deras jobb är att kunna manipulera kortleken, hålla sina poäng 
    samt meddela Game om dem blivit tjocka eller inte. Game, CardHand och CardBank har en kompositionsrelation där banken alltid är sista spelaren. Game får(inject) spelartyp, banktyp och en int 
    som talar om hur många spelare som ska vara med och därefter skapar dem (jag har förberett lite grann för att kunna lägga till fler spelare men just nu stödjer spelet bara 1
    bank och 1 spelare). CardGraphics används i kombination med en 'prettyprint-twig-fil' för att kunna skriva ut lite finare kort. Klassen används även som en referens vid sortering 
    av DeckOfCards då den grafiska representationen är sorterad. <br>
    En tydlig förbättringsåtgärd jag kunnat göra är att flytta ansvaret från Game till CardBank när det gäller att kolla om CardBank är färdig med sin tur. Just nu ligger ansvaret 
    för en stor del av CardBanks tur i gameplayCycle() i Game. Det är lite missvisande då det hade varit bättre om CardBank själv skött den biten och returnat data till Game när 
    dess gameplay-cykel är klar. Det är förvisso ingen svår fix men just nu prioriterar jag att lämna in uppgiften. <br>
    Mina åsikter om Symfony är blandade. Jag tycker det är ett otroligt tungjobbat ramverk som man lätt går vilse i. Men samtidigt verkar man ha kontroll över väldigt mycket 
    smådetaljer. Den största nackdelen är nog dokumentationen, den lämnar mycket att önska och har sällan ett relevant svar på det man söker. Så enkelt sammanfattat, Symfony är 
    inte min 'cup of tea' men samtidigt gillar jag att gå utanför min comfort-zone så jag uppskattar upplevelsen. <br> <br>
    Min TIL är att jag tycker det är svårt att planera innan jag börjar, det är något jag behöver träna på.

    </p>
    <h2 id="kmom04">Kmom04</h2>
    {# Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.

    Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?

    Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?

    Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.

    Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.

    Vilken är din TIL för detta kmom? #}
    <p>Jag är ofta skeptisk mot att göra saker med Php i ren allmänhet, men jag får lov att säga att testerna var trivsamma att arbeta med och erbjöd ett bra flow. Jag har upptäckt att det 
    är ganska svårt att testa sin egen kod på ett kritiskt och konstruktivt sätt. Även att majoriteten av min kod var någorlunda lättestad så tyckte jag det var svårt att komma på sätt att testa sönder 
    min kod. Såklart går allt att ta sönder. Men jag upplever det som en hårfin gräns mellan att testa de delar som är vitala för att en klass ska fungera som tänkt och att skriva 
    extremt riktade tester bara för att klassen ska göra fel. Det jag menar är enkelt utryckt att Det finns alltid små hål att täppa och det är ibland svårt att veta vilka som är värda att 
    lägga energi på.</p><br>

    <p>Jag lyckades ganska bra med kodtäckningen, 100% på Card och 93.75% på Game. Som jag tidigare nämnde tycker dock det är utmanade att skriva opartiska och konstruktiva testfall 
    till min egen kod, det kanske kan vara en Nackdel med såkallad 'White-box-testing'? I allmänhet tycker jag dock min kod i Card var ganska lättestad då jag hade många små funktioner som gjorde 
    få saker. Däremot upptäckte jag att Game-klassen har för många ansvarsområden i gameplayCycle(), getWinner() och getMaxScores() vilket gjorde det svårt att att testa olika delar i funktionerna. 
    Det som har kunnat förbättras där är dels att bryta ut kod till flera mindre funktioner men även att flytta över en del av ansvaret i funktionerna till CardHand/Cardbank-klasserna istället. 
    Jag gjorde dock inga större ändringar i min kod då jag ligger lite efter i kursen och försöker lägga min tid på det som är hårda krav. Men jag har en idé om vad som hade behövts om jag hade hunnit.
    </p><br>
    <p>Är testbar kod snygg och ren? Mja, generellt anser jag nog det. Om man klarar av att balansera den OCD man riskerar att uppleva om ALLT ska vara 100% testbart. Att skriva tester till 
    min kod har helt klart gett mig ett nytt perspektiv på vilka brister och fördelar min skrivna kod har. Flera gånger under testningen hittade jag småsaker som hade kunnat vara mycket bättre 
    om jag gjort på något alternativt sätt och lärdomen jag tar med mig till framtida kodingssessioner när jag sitter och skriver lite tveksamma, bökigare och större funktioner är att ställa mig 
    frågan "Kommer det gå att testa det här på ett någorlunda vettigt sätt?". Jag tror det kommer hjälpa mig att skriva lite bättre kod.</p><br>

    <p>Min TIL är att det faktiskt var lite kul att sitta med tester. Vilket jag inte trodde jag skulle tycka. Jag hade gärna i framtiden sett något moment när man ska testa andras kod för att 
    få ett bredare perspektiv. Jag tar gärna emot en extra mening med kritik på just mina tester och deras tillvägagångssätt då jag tror att om jag får en bättre förståelse för hur man 
    ska tänka när man testar kan vara ett sätt för mig att bli en bättre kodare. Detta kursmoment glömde jag helt bort att göra commits så det kommer se snålt ut på githuben detta kmom. 
</p>
    <h2 id="kmom05">Kmom05</h2>
    {# Gick det bra att jobba igenom övningen med Symfony och Doctrine. Något särskilt du tänkte/reagerade på under övningen?

    Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?

    Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?

    Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?

    Vilken är din TIL för detta kmom? #}
    <p>Generellt gick det ganska smärtfritt att jobba med Doctrine, det kunde vara lite oklart vad som händer vid vissa tillfällen då en del saker sker automagiskt. Men kikade man lite i documentationen 
    eller helt enkelt att bad Gpt förklara ett kodstycke så va det relativt enkelt att ta sig till (jag använder inte Gpt för att skriva kod, där emot använder jag den ofta för att få kodstycken jag inte 
    förstår eller har frågetecken kring förklarade). En kul obervation som jag gjorde under uppgiften, och det tar emot att erkänna, men jag har tidigare haft en 
    relativt negativ bild av Php och dess olika ramverk då det känts krångligt och ointuitivt. Men med lite mer perspektiv och erfarenhet (läser tredje året nu och denna kursen är det enda släpet jag har kvar) så 
    har jag ändrat uppfattning helt och upplever Php och Symfony som relativt "lättarbetat" och genomtänkt. Även integrationen med Doctrine kändes smidigt och genomfördes smärtfritt. Jag tog även ut svängarna 
    och provade att använda Symfonys form builder istället för att göra formulären med Html. Det va lite knepigt att sätta sig in inledningsvis p.g.a Symfonys automagi, men det löste sig ganska snabbt. Jag skapade 
    en Form/LibraryType-klass för att bygga mina formulär i. Det blev definitivt inte den snyggaste formulärlösningen men det va lärorikt och formulären gick väldigt smidigt att integrera med entity managern för 
    databas uppdateringar. </p>
    <p>
    Att jobba med ORM är något jag uppskattar, jag har använt det vid flera olika tillfällen då det blir lättare om så mycket som möjligt kan ha en objektstruktur. Ibland kan det såklart vara frustrerande då querys 
    kan bli lite väl långa och diffusa. Det kan ibland kännas lättare att förstå ren SQL, men allt har sina pros and cons.
     </p>
     <p>Vad gäller användargränssnittet på min app så har jag fösökt följa min tidigare struktur med stora tydliga knappar och lite halvt färgglad struktur. När man kommer tillbaka till ett projekt över ett år 
     senare och har skaffat sig mer och nya kunskaper så ser man oändligt med saker som borde gjorts annorlunda. Det är dock inte aktuellt att göra större förändringar på gammal kod emot slutet av kursmomenten. 
     Som tidigare nämnt, min TIL får vara mitt nya perspektiv om att Php faktiskt kan vara relativt smidigt att jobba med, det krävdes dock en del erfarenhet för att uppnå detta perspektivet.</p>
     <p>Jag har några lint-relaterade problem som jag valt att inte bry mig om då felen finns i filer som har genererats av Doctrine eller Symfony.</p>
    <h2 id="kmom06">Kmom06</h2>
    {# 
    - Hur uppfattade du verktyget phpmetrics och fann du några särskilda bitar mer värdefulla än andra? 
    Var det några särskilda metrics eller bilder du uppskattade?

    - Berätta hur det gick att integrera med Scrutinizer och vilken är din första känsla av verktyget och dess badges? 
    Vilken kodtäckning och kodkvalitet fick du efter första bygget?

    - Hur är din egen syn på kodkvalitet, berätta lite om den? Tror du man kan man påvisa kodkvalitet i någon viss mån med badges eller vad tror du?
    - Vilken är din TIL för detta kmom? #}
    <p>Jag upplevde Phpmetrics reltivt överflödigt, man fick en stor mängd statistik som inte sa mig speciellt mycket. Problemet tycker jag är att man behöver 
    lägga ganska mycket energi på att sätta sig in i vad alla delar betyder, detta tog för mycket tid från resterande del av kursmomentet. Jag osäker på om jag faktiskt hunnit sätta mig in tillräckligt 
    för att använd det på ett halvoptimalt sätt. 
    Phpmetrics saknade bra tooltips och liknande vilket gjorde det frustrerande att använda. Stastik är 
    härligt, men utan tillräckligt med kontext så är det inte värt så mycket. Jag ser klart möjligheter med liknande verktyg, men det var för klumpigt och tungjobbat 
    att sätta sig in i och lyckas med (på runt 20 timmar). </p>
    <p>Scrutinizer var besvärligare än Phpmetrics, det var lite bråkigt att få det att fungera då den har väldigt varierande kvalité på sin feedback vid krashar. Men när 
    verktyget väl var igång så fungerade det som det skulle (om än tungrott). Scrutinizers UI gjorde det väldigt svårt att manövrera och även detta verktyget saknade 
    simpla tooltips och förklaringar på diverse saker. Den enda fördelen var att Scrutinizer faktiskt visade olika fel och försökte förklara varför den ansåg att det var fel. 
    Förklaringarna hade dock varierande kvalitet. Min initiala kodkvalitet vad 9.97 och testtäckningen var 28%.
    Jag inser att jag låter väldigt negativt inställd till detta, men det har främst med användarupplevelsen hos verktygen att göra. Det kändes lite som att backa med släp utan att titta bakåt,
    visst kommer man bakåt, men det är lite oklart om det går vettigt till. Även om jag är kritisk mot dem två verktyg vi använt så ser jag även den teoretiska nyttan med dem. 
    Jag tror att dessa verktyg kan vara mer effektiva i större projekt eller för någon med mer erfarenhet med sådan verktyg. För mig som nybörjare blev de dock lite överväldigande.
    Trots min kritik mot verktygen anser jag att kodkvalitet är ett intressant ämne. Jag har nog inte någon konkret definition, men bland de viktigaste delarna är att koden går relativt lätt att 
    läsa och förstå. När jag skulle ändra på min gamla kod i samband med detta kmom så upplevde jag ibland en frustration över att jag har slarvat på onödiga punkter. Det största misstaget 
    jag hittar i min egna kod är att den har låg cohesion, vilket var anledningen till att jag valde att fokusera mycket på det. Sen är det såklart skillnad på hur man resonerar 
    nu och under tiden jag skrev koden i kmom01-04. 
    </p>
    <p>"Kan man påvisa kodkvalitet i någon viss mån med badges?" Bra fråga, jag skulle nog säga att det hjälper till att ge ett bättre första intryck, men sen hänger det till 
    stor del på vilken kvalité verktygen i bakgrunden som tar fram betygen och badgesen håller. Jag upplever Scrutinizer som relativt opålitligt för den gav min kod 10/10, fast att 
    jag själv kan hitta stora brister i min kodbas utan större ansträngning. För ett oinsatt öga så känns det säkert tryggare, lite som en CE-märkning. Visst låter det bra, 
    men stämmer det verkligen alltid? Troligtvis inte, man kan se det som en bra indikation, men man ska nog inte se det som den enda källan till sanning.
    <br>Min TIL är att jag har blivit bättre på att förstå och tillämpa ett objektorienterat tankesätt på kod. När vi läste denna kursen i årskurs ett så tyckte jag 
    det var väldigt utmanade. Nu har jag själv valt att ta ut svängarna lite på ett mer MVC och objektorienterat sätt i både kmom05-06 genom att använda services och att jobba 
    med Symfonys inbyggda funktionalitet, som exempelvis FormBuilderInterface. Jag hade fler saker jag ville prova men jag har tyvärr begränsad tid.</p>
    
    <h2 id="kmom10">Kmom10</h2>
{# 
För varje krav du implementerat, dvs 1-3, 4, 5, 6, skriver du ett textstycke om ca 5-10 meningar där du beskriver hur du löste kravet. 

Skriv ett allmänt stycke om hur projektet gick att genomföra. 
Problem/lösningar/strul/enkelt/svårt/snabbt/lång tid, etc. 
Var projektet lätt eller svårt? Tog det lång tid? 
Vad var svårt och vad gick lätt? 
Var det ett bra och rimligt projekt för denna kursen?

Avsluta med ett sista stycke med dina tankar om kursen och vad du anser om materialet och handledningen (ca 5-10 meningar). 
Ge feedback till lärarna och förslå eventuella förbättringsförslag till kommande kurstillfällen. 
Är du nöjd/missnöjd? 
Kommer du att rekommendera kursen till dina vänner/kollegor? 
På en skala 1-10, vilket betyg ger du kursen? #}
    <p><b>OBS! det finns ett cheat-sheet i proj/about</b></p>
    <h3>Krav 1, 2 och 3</h3>

    <p> Jag valde att placera all kommunikation med sessionen i SessionService, tanken va att denna skulle bli stateless, men som sagt, tiden går snabbt när 
    man har roligt. Det var lite struligt att få igång då Symfony bara erbjuder SessionInterface out-of-the-box inuti just Controllers. Så för att komma åt SessionInterface inne i 
    SessionService fick jag hämta den genom Dependency Injecta RequestStack stack i SessionService. Det var lite förvirrande först men när jag förstod detta så rullade det på fint, till 
    jag skulle skriva tester. Det orsakade lite huvudbry hur jag faktiskt skulle testa SessionService när den i slutändan blev en mix av Service och logikklass (vilket, som tidigare nämnt 
    inte va tanken). Jag insåg dock att jag övertänkte problemet fram till jag insåg att MockArraySessionStorage() fanns. Sen gick testande ganska smärtfritt (bortsett från ett och 
    annat handhavandefel). Mitt mål var att göra AdventureGameControllern så liten som möjligt. Jag anser att lyckats med det (trots tidsbristen) då det inte ligger överdrivet mycket 
    logik i den. Routsen är modulära då dem kan användas till alla möjliga rum som innehåller funktionaliteten så som "action", "forward, "item" och så vidare. Kikar man på bilden 
    nedan så ser man strukturen på varje rum hur varje rum leder till nästa. Rummen innehåller saker att göra (actions, tex "attack"), saker att plocka upp (items, tex "sword") 
    samt vägar att går och bildklass (bakgrunden för varje rum laddas med CSS). Detta innebär att koden är väldigt modulär och man kan skriva egna banor som man sedan injectar i 
    AdventureGame-klassens konstruktor. Det finns olika routes som hanterar de olika handlingarna man kan ta. Exempelvis så hanterar "/proj/adventure/next_room_handler" vad som ska 
    hända när man går till nästa kopplade rum (tex forward leder till ett nytt rum). '/proj/adventure/interact_handler' hanterar och uppdaterar session när spelaren plockat upp ett 
    föremål och lagt i sin backpack så att föremålet sparas hos spelaren samt plockas bort i ifrån rummet man är i, med andra ord, om man plockar upp svärdet så är det kommer det inte 
    synas om man går tillbaka till rummet senare. Detta hade såklart funkat minst lika bra att göra mot en databas, men som tidigare nämnt är tiden kort. Observera att jag har gjort det 
minimum som finns för att den standard-banan som finns ska fungera, exempelvis finns ingen väg för "right" i spelet då jag inte behövde det. Det är dock väldigt enkelt att lägga till, det enda 
man behöver göra copy-pasta "left" diven i html/twig-filen och uppdatera den för att hantera "right" istället.</p> 
<p>Det finns lite valideringsfel i min kod som jag inte brytt mig om att hantera då det främst kommer från genererad kod från Doctrine. Jag kom upp till 78% kodtäckning enligt Scrutinizer, jag siktade på 90% 
men valde att stanna där då jag testat det som är testbart. Ska jag göra mer tester så blir det en tidsfråga, och jag har redan lagt mycket tid så detta känns rimligt.</p>

    <img class="rooms-pic" src="{{ asset('img/rooms_vis.png') }}" alt="Pic rooms game structure ">

    <h3>Allmänt om projektet</h3>
    <p>Generellt gick det ganska ok att genomföra projektet. Det stora problemet är att jag inte kodar likadant som jag gjorde för ett och ett halvt år sedan när denna kursen gick. 
    Det är väldigt många saker som jag vill göra men som helt enkelt tar för lång tid. Jag hade tänkt implementera stateless services med interfaces till sessioner och/eller databas. Men 
    med tanke på att jag inte är så van vid Php så tar det väldigt mycket tid att sätta sig in i hur man gör alla delar i just Php/Symfony. Jag lyckades rent teoretiskt relativt 
    bra med att hålla logiken utanför AdventureGameController, men jag insåg efter ett tag att det redan gått mycket tid så jag fick börja snåla in på vad jag tänkt göra ganska 
    drastiskt. Just att uppskatta och planera för hur lång tid något kommer ta är en svaghet jag har. <br> Dem största problem jag har haft har varit Symfony- och config-relaterade, 
    exempelvis så bestämde sig Webpack för att helt plötsligt packetera programmet på ett sätt så att webbläsaren inte hittade hälften av filerna när appen kördes på studentservern. 
    Det var dock en reltivt enkel fix, jag ändrar ".setPublicPath('/build')" till ".setPublicPath('/~emkl21/dbwebb-kurser/mvc/me/report/public/build')" i webpack.config.js innan jag ska 
    publisera till studentservern.</p> 
    <p>Med en ödmjuk ton skulle jag säga att projektet hade varit ganska klurigt om jag hunnit göra det när jag skulle i årskurs ett. Nu har jag medvetet gjort det svårt för mig 
    genom att prova nya saker (vissa saker fungerade inte så då fick jag skrota dem, fast jag lärde mig något) då jag känner att jag vill lära mig på vägen och inte bara "ta mig igenom kursen". 
    Så jag hoppas på lite översyn om jag gjort något okonvetionellt under tiden jag provat på olika saker. En av dem större utmaningarna var såklart Css och att få alla bilder att stanna där jag vill, 
    men, kombinerar man flexbox med lite tålamod så blir det helt ok tillslut.</p>
    <p>
    Jag anser det vara extra utmanande att programmera för spel. Tänker man inte steget längre hela tiden så riskerar man att producera väldigt klumpig kod som inte är modulär. Jag och några kompisar har en 
    game-dev/jam-träff (Godot-motorn) en gång i månaden och jag upplever liknande utmaningar där också, är man inte steget för så riskerar man besvärlig kod. Hoppas även att mina konstverk som jag ritat (jag ritade 
    alla bilder själv lite snabbt för det kändes som att det skulle ta ännu längre tid att hitta bilder som passade mitt upplägg) är tydliga nog för att man ska se vad det föreställer.
    </p>

    <h3>Feeback</h3>
    <p>
    Det var rätt längesedan jag gick denna kurs så jag vet inte riktigt om jag har något att komma med, jag svarade på kursutvärderingen iaf och jag relativt positiv feedback vill jag minnas. Det enda jag tänkte på 
    är att man riskerar att bli lite indirekt straffad rent betygsmässigt beroende på vilket projekt man väljer. Kortspelet som fanns som alternativ kändes som att man nästan var halvfärdigt med innan man ens började. 
    Jag bryr mig inte jättemycket om betyg dock, så jag valde det som kändes mest roligt och utmanande, men det var ändå en tanke som dök upp.
    Men annars tycker jag kursen var givande och intressant och gav utrymme för att prova på mycket olika saker.
    </p>

{% endblock %}