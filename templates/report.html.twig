{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report</h1>
    <a style="margin-bottom: 0.7rem" href="#kmom01">kmom01</a>
    <a style="margin-bottom: 0.7rem" href="#kmom02">kmom02</a>
    <a style="margin-bottom: 0.7rem" href="#kmom03">kmom03</a>
    <a style="margin-bottom: 0.7rem" href="#kmom04">kmom04</a>
    <a style="margin-bottom: 0.7rem" href="#kmom05">kmom05</a>
    <a style="margin-bottom: 0.7rem"href="#kmom06">kmom06</a>
    <a style="margin-bottom: 0.7rem" href="#kmom10">kmom10</a>
    <h2 style="margin-top:1.4rem;" id="kmom01">Kmom01</h2>
    {# <p>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.
Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver 
veta/förstå för att kunna komma igång och skapa sina första klasser?
Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?

Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? 
Är det några särskilda områden som du känner att du vill veta mer om? Lyft fram några delar av artikeln som du känner mer värdefulla. #}

<p>Den enda direkta tidigare erfarenheten jag har med objektorientering är från OOPython-kursen. Spontant känns det ju som principen med 
OOp är densamma i många olika språk. Simpelt och generellt beskrivet är det ett sätt att skapa objekt som håller sina egna 
attribut och funktioner. Vilket låter som en logisk modell då människan har ett objektorienterad tankesätt, alla saker har sitt 
användningsområde. Generellt tycker jag PHPs sätt att skapa klasser och objekt påminner mycket om hur man gör i Python. Exempelvis hur man jobbar med 
eventuell konstruktor, setters och getters. Det som tydligt skiljer är att inget är privat i Python där använder man endast en namnkonvention för att visa att något 
ska hanteras som en tex privat attribut (_attribute). Försöker vi hantera ett privat attribut i PHP som ett publikt (utan setters/getters) så kommer vi få krashad kod eller massa fel. <br> <br>

Frågan "Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver 
veta/förstå för att kunna komma igång och skapa sina första klasser?" är inte helt självklar gällande vilket svar man min ha. Men 
ska man svara basic så bör man ha en uppfattaning om hur man ska tänka när man deklarerar sina attribut (ska dem vara public, prot, eller private?). 
Rimligt är också om man förstår vad en konstruktor gör samt att när ett object väl är skapat så är objektet en egen instans med ett eget 
state skapat utifrån en klass, man kan säga att klassen är en form av blueprint för ett eventuellt objekt. Ett annat sätt att se på det är att klasser 
är en möjligthet a samla kod som är relevanta för varandra och på så sätt få en bättre struktur och läsbarhet. <br><br>

Strukturen som används i denna uppgiften känns greppbar. Symfony upplevs inledningsvis som stort och tungjobbat när man kommer direkt från att ha använt Express(js). 
Men jag får uppfattningen att Symfony är lite mindre 'magiskt' än tex Express och ger användaren mer manuella möjligheter att hantera problem. Det känns såklart lite 
överväldigande i början men det leder i slutändan till en (förhoppningsvis) djupare förståelse för det man jobbar med. Phps dokumentation är dock ungefär lika 
smidig som Pythons vilket är lite synd, men så är det ibland. <br>


Artikeln 'PHP The right way' föll inte riktigt mig i smaken, det kändes väldigt svårt att avgöra vad som är är viktigt just nu och upplägget bär på samma misstag 
som dem flesta introduktionsartiklar, dem lägger tex 10 meningar på att förklara att en ny sak har kommit sedan version X och den är jättebra o.s.v.  sen efter massa 
(för tillfället) onödiga förklaringar skriver dem en mening om hur man ska använda funktionen/tekniken. Jag misstänker att artikeln blir mer användbar 
ju djupare man behöver dyka i PHP, men vid första anblick känns den lite oinspirerande. Nu lät jag lite negativ, den hade också såklart lite intressanta saker att bjuda på så som 
<a class="a-reset" href="https://phptherightway.com/#openclosed-principle">Open/closed principle</a> vilket är något jag, har blivit, men vill bli mycket bättre på. 
<br><br>
Än sålänge har min sida en grundläggande responsivitet men saknar en del anpassning i navbaren och andra småställen. Jag är osäker på hur mobilanpassad sidan behöver vara så jag 
har bara gjort lite basic anpassning.</p>

    <h2 id="kmom02">Kmom02</h2>
    {# Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.
    Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?
    
    Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod.
    Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?

    Vilken är din TIL för detta kmom? #}
    <p>Arv är ett sätt att strukturera sin kod mer eller mindre. Det innebär att man enklare kan strukturera sin kod i relevanta 'hierarkier'. Som 
    exempel kan vi ta klassikern att (nästan) alla bilar har har attributen en motor och fyra hjul samt metoden gasa(), men färgen kan variera från bil till bil. Då kan vi göra en 
    Bil-klass som har dem relevanta attributen och metoderna för en bils grundliga funktioner. Sedan kan en annan subklass ärva från Bil och på så sätt få
    med sig basmetoderna från Bil. Då kan subklassen fokusera på att specialisera bilen åt något annat håll, typ ändra färg. </p>
    <p>Komposition är en typ av livlineförhållande. Om klassen X som håller/använder sig av Y slutar existera så kommer även klassen Y att försvinna. Man kan  
    jämföra det med att om ett företag går i konkurs/upphör så kommer dem anställdas 'Anställning' försvinna då det i detta fall krävs ett Företag för att erbjuda ett anställningskontrakt.</p>
    <p>När man läser om Interface påminner beskrivningen om hur abstrakta klassmetoder fungerade i Python. Det är ett sätt att tvinga t.e.x en subklass att uppfylla dem 
    krav och funktionerna en klass förväntas ha, beroende på vad det är för klass. Är det ett kortspels-interface så förväntas åtminstonde en deal och shuffle-metod. På så 
    sätt kan kod blir med återanvändbar då jag rent teoretiskt skulle kunna stoppa in vilken kortlek som helst i en kortklass som lyder under ett kortspels-Interface.</p>
    <p>Ett Trait är en samling återanvändbar kod som kan användas i olika klasser. Det är ett alternativ till Arv, i Php kan man inte ärva från flera Föräldraklasser. Då 
    kan trait vara ett alternativ för att lyckas dela kod mellan olika klasser istället. När en klass använder ett trait så kan klassen använda traitens metoder. En tydlig skillnad 
    mellan Trait och Klass, enligt <a class="a-reset" href="https://www.php.net/manual/en/language.oop5.traits.php">Php manualen om Traits</a>, är att ett Trait inte kan instansierias fristående, så som 
    en klass kan.</p>
    <p>Jag är ganska nöjd med min implementation och tycker jag har fått mycket gjort med ganska lite kod. Jag valde dock att inte använda mig av Cards-klassen utan jag gjorde 
    bara en CardGraphics-klass. Anledningen till det är att jag valde att utgå ifrån att en ny kortlek är sorterad och i rätt antal från början. Jag använde mig av ChatGPT för att 
    snabbt göra två arrayer (en value och en key,value) som skulle motsvara kortleken och dess grafik och på så sätt tog det mig ingen tid att påbörja det upplägget. Om jag skulle 
    skrivit båda arrayerna manuellt hade jag nog valt ett annat sätt att skapa kortleken, med tex loopar. Men en vanlig kortlek har alltid 52 kort så jag behövde inte ta hänsyn till 
    några eventuella förändringar på den fronten och det är alltid kul att nyttja sig av ny teknik (Obs, jag har INTE använt ChatGPT för att skriva någon kod utan endast för att underlätta 
    formateringen/framställningen av kort-arrayerna.). <br>
    En sak som skulle kunnat vara bättre är att jag ibland har/hade lite dubblettmetoder som gör samma sak med kortleken i handen beroende på vart du använder metoden(i CardHand eller 
    i DeckOfCards) och det kunde vara vilseledande ibland. Jag har dock rensat bort (nästan) alla onödiga dubblettmetoder och försökt hålla alla metoder som hämtar eller sätter information 
    om DeckOfCards i DeckOfCards samt alla manipulerande metoder i CardHand för att få en lite mer logisk struktur</p>
    <p>Jag missade helt detaljen om att man skulle göra ett UML-diagram och såg detta när jag dubbelkollade kraven innan inlämning. Vilket är lite synd för min del då jag i tidigare kurser 
    märkt att jag skriver lite mer strukturerad kod när jag har en mall att utgå ifrån. Mitt TIL för detta kmom är det jag lärt mig om Trait och Interface. Jag har dock inte nyttjat 
    någon av dem mekanismerna i min kod men jag vill prova på dem längre fram.</p>
    <h2 id="kmom03">Kmom03</h2>
    {# Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i 
    din problemlösning och tankearbete för att strukturera koden kring en applikation?
    Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, 
    vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?
    Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?
    Vilken är din TIL för detta kmom? #}
    <p>
    Jag gjorde först ett flödesdiagram med flödeslogiken jag ville ha i spelet. Jag har inte tittat så mycket på flödesdiagramet då jag gjorde en ganska stark mental 
    notering på hur jag ville jobba under tiden jag gjorde diagramet. Så det var klart ett hjälpmedel, men främst i början för att få igång en vettig och målinriktad start. Jag 
    skrev lite pseudokod innan jag började skriva men jag valde ganska snabbt att skriva den i ett listformat istället då jag var osäker på vad jag behövde för funktioner och struktur, 
    sedan fyllde jag på den lite efter hand. 
    Då kändes det mer hjälpsamt att ha en lista att gå efter som nämner dem flesta grundstenar. En lärdom jag fått av att försöka skriva pseudokod är att jag upplever det som svårt 
    att börja visualisera mig vad jag kommer/inte kommer att behöva i ett sådant tidigt stadie. Det mesta brukar komma när jag fått ihop en grundstruktur, i detta fall avser jag 
    grundstruktur som exempelvis routes och en startsida/slutsida. <br> <br>
    Innan jag började göra någon riktig kodning så gjorde jag alla routes jag kunde tänka mig, framförallt en 'lekroute' som jag använde mycket i början för att prova grundläggande funktioner. 
    Jag implementerade alla klasserna och såg till att jag kunde göra grundläggande saker (dra kort osv, det som gjordes i kmom02). Koden jag skrev i kmom02 har varit smidig att 
    jobba med och jag tycker att jag gjorde ett bra jobb i kmom02 med att förbereda klasserna för kortspelet. <br><br>
    Den grundläggande strukturen i kortspelet är att Game-klassen hanterar spelets flöde, såsom att hålla kolla på vems tur det är, hålla antal spelare, låta spelaren dra ett kort eller 
    inte och utse en vinnare mm. CardHand och CardBank(CB ärver från CH) representerar en spelare och en bank och deras jobb är att kunna manipulera kortleken, hålla sina poäng 
    samt meddela Game om dem blivit tjocka eller inte. Game, CardHand och CardBank har en kompositionsrelation där banken alltid är sista spelaren. Game får(inject) spelartyp, banktyp och en int 
    som talar om hur många spelare som ska vara med och därefter skapar dem (jag har förberett lite grann för att kunna lägga till fler spelare men just nu stödjer spelet bara 1
    bank och 1 spelare). CardGraphics används i kombination med en 'prettyprint-twig-fil' för att kunna skriva ut lite finare kort. Klassen används även som en referens vid sortering 
    av DeckOfCards då den grafiska representationen är sorterad. <br>
    En tydlig förbättringsåtgärd jag kunnat göra är att flytta ansvaret från Game till CardBank när det gäller att kolla om CardBank är färdig med sin tur. Just nu ligger ansvaret 
    för en stor del av CardBanks tur i gameplayCycle() i Game. Det är lite missvisande då det hade varit bättre om CardBank själv skött den biten och returnat data till Game när 
    dess gameplay-cykel är klar. Det är förvisso ingen svår fix men just nu prioriterar jag att lämna in uppgiften. <br>
    Mina åsikter om Symfony är blandade. Jag tycker det är ett otroligt tungjobbat ramverk som man lätt går vilse i. Men samtidigt verkar man ha kontroll över väldigt mycket 
    smådetaljer. Den största nackdelen är nog dokumentationen, den lämnar mycket att önska och har sällan ett relevant svar på det man söker. Så enkelt sammanfattat, Symfony är 
    inte min 'cup of tea' men samtidigt gillar jag att gå utanför min comfort-zone så jag uppskattar upplevelsen. <br> <br>
    Min TIL är att jag tycker det är svårt att planera innan jag börjar, det är något jag behöver träna på.

    </p>
    <h2 id="kmom04">Kmom04</h2>
    {# Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.

    Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?

    Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?

    Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.

    Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.

    Vilken är din TIL för detta kmom? #}
    <p>Jag är ofta skeptisk mot att göra saker med Php i ren allmänhet, men jag får lov att säga att testerna var trivsamma att arbeta med och erbjöd ett bra flow. Jag har upptäckt att det 
    är ganska svårt att testa sin egen kod på ett kritiskt och konstruktivt sätt. Även att majoriteten av min kod var någorlunda lättestad så tyckte jag det var svårt att komma på sätt att testa sönder 
    min kod. Såklart går allt att ta sönder. Men jag upplever det som en hårfin gräns mellan att testa de delar som är vitala för att en klass ska fungera som tänkt och att skriva 
    extremt riktade tester bara för att klassen ska göra fel. Det jag menar är enkelt utryckt att Det finns alltid små hål att täppa och det är ibland svårt att veta vilka som är värda att 
    lägga energi på.</p><br>

    <p>Jag lyckades ganska bra med kodtäckningen, 100% på Card och 93.75% på Game. Som jag tidigare nämnde tycker dock det är utmanade att skriva opartiska och konstruktiva testfall 
    till min egen kod, det kanske kan vara en Nackdel med såkallad 'White-box-testing'? I allmänhet tycker jag dock min kod i Card var ganska lättestad då jag hade många små funktioner som gjorde 
    få saker. Däremot upptäckte jag att Game-klassen har för många ansvarsområden i gameplayCycle(), getWinner() och getMaxScores() vilket gjorde det svårt att att testa olika delar i funktionerna. 
    Det som har kunnat förbättras där är dels att bryta ut kod till flera mindre funktioner men även att flytta över en del av ansvaret i funktionerna till CardHand/Cardbank-klasserna istället. 
    Jag gjorde dock inga större ändringar i min kod då jag ligger lite efter i kursen och försöker lägga min tid på det som är hårda krav. Men jag har en idé om vad som hade behövts om jag hade hunnit.
    </p><br>
    <p>Är testbar kod snygg och ren? Mja, generellt anser jag nog det. Om man klarar av att balansera den OCD man riskerar att uppleva om ALLT ska vara 100% testbart. Att skriva tester till 
    min kod har helt klart gett mig ett nytt perspektiv på vilka brister och fördelar min skrivna kod har. Flera gånger under testningen hittade jag småsaker som hade kunnat vara mycket bättre 
    om jag gjort på något alternativt sätt och lärdomen jag tar med mig till framtida kodingssessioner när jag sitter och skriver lite tveksamma, bökigare och större funktioner är att ställa mig 
    frågan "Kommer det gå att testa det här på ett någorlunda vettigt sätt?". Jag tror det kommer hjälpa mig att skriva lite bättre kod.</p><br>

    <p>Min TIL är att det faktiskt var lite kul att sitta med tester. Vilket jag inte trodde jag skulle tycka. Jag hade gärna i framtiden sett något moment när man ska testa andras kod för att 
    få ett bredare perspektiv. Jag tar gärna emot en extra mening med kritik på just mina tester och deras tillvägagångssätt då jag tror att om jag får en bättre förståelse för hur man 
    ska tänka när man testar kan vara ett sätt för mig att bli en bättre kodare. Detta kursmoment glömde jag helt bort att göra commits så det kommer se snålt ut på githuben detta kmom. 
</p>
    <h2 id="kmom05">Kmom05</h2>
    {# Gick det bra att jobba igenom övningen med Symfony och Doctrine. Något särskilt du tänkte/reagerade på under övningen?

    Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?

    Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?

    Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?

    Vilken är din TIL för detta kmom? #}
    <p>Generellt gick det ganska smärtfritt att jobba med Doctrine, det kunde vara lite oklart vad som händer vid vissa tillfällen då en del saker sker automagiskt. Men kikade man lite i documentationen 
    eller helt enkelt att bad Gpt förklara ett kodstycke så va det relativt enkelt att ta sig till (jag använder inte Gpt för att skriva kod, där emot använder jag den ofta för att få kodstycken jag inte 
    förstår eller har frågetecken kring förklarade). En kul obervation som jag gjorde under uppgiften, och det tar emot att erkänna, men jag har tidigare haft en 
    relativt negativ bild av Php och dess olika ramverk då det känts krångligt och ointuitivt. Men med lite mer perspektiv och erfarenhet (läser tredje året nu och denna kursen är det enda släpet jag har kvar) så 
    har jag ändrat uppfattning helt och upplever Php och Symfony som relativt "lättarbetat" och genomtänkt. Även integrationen med Doctrine kändes smidigt och genomfördes smärtfritt. Jag tog även ut svängarna 
    och provade att använda Symfonys form builder istället för att göra formulären med Html. Det va lite knepigt att sätta sig in inledningsvis p.g.a Symfonys automagi, men det löste sig ganska snabbt. Jag skapade 
    en Form/LibraryType-klass för att bygga mina formulär i. Det blev definitivt inte den snyggaste formulärlösningen men det va lärorikt och formulären gick väldigt smidigt att integrera med entity managern för 
    databas uppdateringar. </p>
    <p>
    Att jobba med ORM är något jag uppskattar, jag har använt det vid flera olika tillfällen då det blir lättare om så mycket som möjligt kan ha en objektstruktur. Ibland kan det såklart vara frustrerande då querys 
    kan bli lite väl långa och diffusa. Det kan ibland kännas lättare att förstå ren SQL, men allt har sina pros and cons.
     </p>
     <p>Vad gäller användargränssnittet på min app så har jag fösökt följa min tidigare struktur med stora tydliga knappar och lite halvt färgglad struktur. När man kommer tillbaka till ett projekt över ett år 
     senare och har skaffat sig mer och nya kunskaper så ser man oändligt med saker som borde gjorts annorlunda. Det är dock inte aktuellt att göra större förändringar på gammal kod emot slutet av kursmomenten. 
     Som tidigare nämnt, min TIL får vara mitt nya perspektiv om att Php faktiskt kan vara relativt smidigt att jobba med, det krävdes dock en del erfarenhet för att uppnå detta perspektivet.</p>
     <p>Jag har några lint-relaterade problem som jag valt att inte bry mig om då felen finns i filer som har genererats av Doctrine eller Symfony.</p>
    <h2 id="kmom06">Kmom06</h2>
    {# 
    - Hur uppfattade du verktyget phpmetrics och fann du några särskilda bitar mer värdefulla än andra? 
    Var det några särskilda metrics eller bilder du uppskattade?

    - Berätta hur det gick att integrera med Scrutinizer och vilken är din första känsla av verktyget och dess badges? 
    Vilken kodtäckning och kodkvalitet fick du efter första bygget?

    - Hur är din egen syn på kodkvalitet, berätta lite om den? Tror du man kan man påvisa kodkvalitet i någon viss mån med badges eller vad tror du?
    - Vilken är din TIL för detta kmom? #}
    <p>Jag upplevde Phpmetrics reltivt överflödigt, man fick en offantlig mängd statistik som inte sa mig speciellt mycket. Problem kan jag tycka är att man behöver 
    lägga ganska mycket energi för att sätta sig in i vad alla delar betyder, detta tar helt enkelt för mycket tid från resterande del av kursmomentet. Så ärligt talat 
    är jag osäker på om jag använd det på rätt sätt eller inte. Verktyget saknade även bra tooltips och liknande vilket gjorde det frustrerande att använda. Stastik är 
    härligt, men utan tillräckligt med kontext så är det inte värt så mycket. Jag ser klart möjligheter med liknande verktyg, men detta var alldeles för klumpigt och tungjobbat 
    att sätta sig in i och lyckas med (på runt 20 timmar). </p>
    <p>Scrutinizer var ännu värre än Phpmetrics, det var lite besvärligt att få det att fungera då den har väldigt varierande kvalité på sin feedback vid krashar. Men när 
    verktyget väl var igång så fungerade det som det skulle (om än tungrott). Scrutinizers UI gjorde det väldigt svårt att manövrera och även detta verktyget saknade 
    simpla tooltips och förklaringar på diverse saker. Den enda fördelen var att Scrutinizer faktiskt visade olika fel och försökte förklara varför den ansåg att det var fel. 
    Förklaringarna hade dock varierande kvalitet. Min initiala kodkvalitet vad 9.97 och testtäckningen var 28%.
    Jag inser att jag låter väldigt negativt inställd till detta, men det har främst med användarupplevelsen hos verktygen att göra. Det kändes lite som att backa med släp utan att titta bakåt,
    visst kommer man bakåt, men det är lite oklart om det går vettigt till.
    Annars anser jag att kodkvalitet är ett intressant ämne. Jag har nog inte någon konkret definition, men bland de viktigaste delarna är att koden går relativt lätt att 
    läsa och förstå. När jag skulle ändra på min gamla kod i samband med detta kmom så upplevde jag ibland en frustration över vad jag har slarvat på. Det största misstaget 
    jag hittar i min egna kod är att den har låg cohesion, vilket var anledningen till att jag valde att fokusera mycket på det. Sen är det såklart skillnad på hur man resonerar 
    nu och under tiden jag skrev koden i kmom01-04. 
    </p>
    <p>Kan man påvisa kodkvalitet i någon viss mån med badges? Bra fråga, jag skulle nog säga att det hjälper till att ge ett bättre första intryck, men sen hänger det till 
    stor del på vilken kvalité verktygen i bakgrunden som tar fram betygen och badgesen håller. Jag upplever Scrutinizer som relativt opålitligt då den gett min kod 10/10, fast att 
    jag själv kan hitta stora brister i min kodbad utan större ansträngning. Får ett oinsatt öga så känns det säkert tryggare, lite som en CE-märkning. Visst låter det bra, 
    men stämmer det verkligen alltid? Min TIL är att jag har blivit bättre på att förstå och tillämpa ett objektorienterat tankesätt på kod. När vi läste denna kursen i årskurs ett så tyckte jag 
    det var väldigt utmanade. Nu har jag själv valt att ta ut svängarna lite på ett mer MVC och objektorienterat sätt i både kmom05-06 genom att använda services och att jobba 
    med Symfonys inbyggda funktionalitet, som exempelvis FormBuilderInterface.</p>
    <h2 id="kmom10">Kmom10</h2>
    <p>Kmom1</p>

{% endblock %}